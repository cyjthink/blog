## Overview

- [判断对象是否需要被回收的算法](#判断对象是否需要被回收的算法)
  - [ 引用计算法](# 引用计算法)
  - [可达性分析法](#可达性分析法)
- [回收的算法](#回收的算法)
  - [“标记-清理”算法](#"标记-清理"算法)
  - [复制算法](#复制算法)
  - [“标记-整理”算法](#"标记-整理"算法)
  - [分代收集算法](#分代收集算法)

## 判断对象是否需要被回收的算法

### 引用计算法

给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时计算器减1；当计数器为0时，则该对象为可回收对象。

1. 缺点：很难处理对象间的循环引用

### 可达性分析法

通过一系列GC Roots 对象为起点向下搜索，走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连接时，则该对象为可回收对象。

## 回收的算法

### “标记-清理”算法

首先标记出所有需要回收的对象，在标记完成后统一回收

1. 缺点
   1. 效率问题，标记与清理的操作效率不高
   2. 空间问题，回收后会产生大量不连续的内存碎片，当需要分配一个较大对象时无法找到足够连续的内存而提前GC

### 复制算法

将可用内存按容量划分为相同的两块，每次只使用1块。当一块内存用完时，将剩余的存活对象复制到另一块内存上，再把已使用的内存空间一次清理掉。

1. 优点：内存分配时不用考虑内存碎片的问题
2. 缺点：
   1. 将可用内存缩小为原来的一半
   2. 在对象存活率较高的时候需要进行较多的复制，效率变低
3. 解决方案：使用分代方式。将内存分为一块较大的Eden和两块较小的Survivor空间，每次使用Eden和一块Survivor。当回收时将Eden和Survivor中存活的对象复制到另一块Survivor上，再清理掉已使用的空间。如果剩下的Survivor空间不够存放存活的对象时，需要依赖其他内存进行分配担保

### “标记-整理”算法

标记出所有需要回收的对象，将存活的对象向一端移动，再从边界开始清理可回收对象

### 分代收集算法

根据对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都有大批对象死去，那就选择复制算法进行回收；在老年代中，对象存活率较高，没有额外的空间对它进行分配担保，则使用“标记-清理”或“标记-整理”算法进行回收